Краткий фидбек по Нории.

Во-первых, я очень старался научиться на Нории программировать. Полгода я честно пытался понять как лучше всего на ней писать. Что-то прояснилось, а что-то до сих пор проблема и мне кажется пора на оставшееся трезво взглянуть. НЕ взгляд новичка, а взгляд того, что осталось в осадке.

Во-вторых, что получилось.

Инкрементальность и реактивность как будто наконец работает. Это прикольная модель программирования. Если представить, что мы бы решили все проблемы (см. ниже), это было бы удобнее React.

Модель лайаута и констрейнтов как будто складывается. То есть каких-то принципиальных проблем я не вижу, надо просто нарастить мяса.

А теперь про проблемы. Еще раз, это не про «не разобрался» или «не понял», это проблемы, которые встречаются у нас до сих пор и разбираться с которыми занимает огромное количество усилий и времени у всех нас.

Во-первых, штука с замыканиями очень хрупкая. ОЧЕНЬ легко захватить то, что ты не хотел. Можно очень легко захватить this. Можно захватить var и поиметь проблему с замыканием на ссылку вместо значения. Легко захватить `x` через `x.field`, вместо того чтобы вынести `val y = x.field` и замыкаться на `y`.

Очень трудно понять, какие из замыканий работают, а какие нет. Те, которые мы находили so far это случайные случаи, которые обнаруживали себя по косвенным признакам через совсем другие проблемы. То есть мы пишем всю эту инкрементальность и feel good about ourselves, на практике хорошо если половина из них по делу и половина из этой половины работает.

Болтающиеся неубираемые под ногами `expr {}` в _юзерском_ коде не очень удобно, можно привыкнуть. НО есть подозрение что на релизе по ним будет бесконечное количество вопросов и они никогда не закончатся. Возможно, можно будет спрятать `expr`, оборачивающие компоненты, в DSL?

Иногда инкрементальности не хватает. Сейчас это такой неуправляемый кэш по N неявным аргументам, захваченным лямбдой. Совпали — вот тебе старое значение, не совпали — считай новое. Хотелось бы больше гибкости: решать, от кого и как зависеть. Скажем, я использую только maxWidth из constraints, но сравнение идет по всему constraints. Или если новые constraints строго больше старых, не перевычисляться. Или иметь доступ к прошлому значению, чтобы выковырять из него кусочки, которые актуальны, и пересчитать только все остальное.

В теории часть из этих проблем можно решить кастомным reconciler или очень точечными thunks, то есть это не принципиальная проблема фреймворка, а чисто практическая. Например, в нашем случае компонент не решает, с каким reconciler его позовут. То есть если например я знаю что после определенного предела роста constraints текст можно не лэйяутить заново, то мне некуда это знание деть: контейнер меня позовет все равно с обычным реконсайлером и будет кэшировать меня по строгому equals для constraints. На практике, где это встречается — лайаут строки текста, оверскролл в скролле.

Кастомный реконсайлер, кстати, довольно сложно написать, опять таки, из-за хрупкости всяких инлайн лямбд в котлине, наших скоупов и того, чтобы все это работало. Не знаю, можно ли это упростить. 

Бесконечные лямбды. С этим просто очень трудно работать, когда у тебя нет какой-то конкретной, вещественной штуки, которую можно пощупать руками и которая никуда не уплывает. Вместо этого в нашем подходе (опять, не принципиальная проблема, чисто практическая) очень много всего создается на лету — стейт, компоненты — все это не существует где-то перманентно, а замкнуто в локальном биндинге пробегавшей мимо лямбды и больше нигде. С этим очень сложно разбираться и инспектировать, когда ты не можешь просто все что у тебя есть разложить перед собой.

Несинхронные события. Если за кадр произошло больше одного события, нория будет их копить. Проблема в том, что чтобы правильно посчитать второе событие, тебе нужно состояние, как если бы применилось первое. У нас же в момент применения второго события первое будет все еще сидеть в очереди и стейт нории будет старым. Из-за этого мы видим частые reading thunk that doesn’t exist например. Всякие drag-n-drop работают не очень точно.

Coupling бизнес логики, рендера и событий. Это все происходит сейчас в render методе, что не очень здорово, хотелось бы эти вещи разделять и раздельно ими управлять.

В осадке, для меня шоу стопперами подхода являются хрупкость и негибкость. Странно представить, что мы выкатим надежную и стабильную систему, когда сама среда под нами мешает этому. Это примерно как программировать на C и надеяться, что не словишь Segmentation fault. Ошибка не в том, что ты затупил в конкретном каком-то месте. Ошибка в том, что ты выбрал C.

Хорошая новость в том, что все в наших руках! Мы сами можем создать среду, в которой правильный код (надежный, эффективный) будет написать проще, чем неправильный. Что я предлагаю? Пока ничего не предлагаю. Мы потратили полгода, чтобы проверить гипотезу — хорошо. Как ощущения? Какие еще подходы можно попробовать? Смогли бы мы написать все то же самое без инкрементальности? Если да, то как? Что было бы лучше? Что хуже?